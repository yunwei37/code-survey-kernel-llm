% \documentclass[conference]{IEEEtran}
% \IEEEoverridecommandlockouts
\documentclass[sigconf,review,anonymous]{acmart}
\renewcommand\footnotetextcopyrightpermission[1]{}
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
% \usepackage{cite}

\settopmatter{printfolios=true}
% make references clickable 
\usepackage[]{hyperref}

\settopmatter{printfolios=true}
\settopmatter{printacmref=false}
\pagestyle{plain}
\usepackage{tikz}
\usepackage{float}
\usepackage{amsmath}
\usepackage{xspace}
\usepackage{cleveref}
\usepackage{balance}
\usepackage{url}
\usepackage{siunitx}
\usepackage{comment}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{makecell}
\usepackage{algorithm2e}
\usepackage{multirow}
% \usepackage{minted}
\usepackage{graphicx}
\usepackage[thicklines]{cancel}
\usepackage{caption}
% \def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    % T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Author information removed for double-blind review
% \author{Yusheng Zheng}
% \affiliation{%
%   \institution{Eunomia. Inc.}
%   \country{USA}
% }
% \email{yunwei356@gmail.com}
% \author{Yiwei Yang}
% \affiliation{%
%   \institution{UC Santa Cruz}
%   \country{USA}
% }
% \email{yyang363@ucsc.edu}
% 
% \author{Haoqin Tu}
% \affiliation{%
%   \institution{UC Santa Cruz}
%   \country{USA}
% }
% \email{tuisaac163@gmail.com}
% 
% \author{Yuxi Huang}
% \affiliation{% 
%   \institution{Eunomia. Inc.}
%   \country{USA}
% }
% \email{yuxi4096@gmail.com}

% \title{Do we really know how the system works? Automatic agent system for code behavior analysis}
% \title{\sys: An LLM-Driven Methodology for Analyzing Large-Scale Codebases}
\title{\sys: A Multi-Agent LLM Framework for Understanding the Linux Kernel}

% \newcommand{\hq}[1]{\textcolor{blue}{[Haoqin: #1]}} % Commented for anonymity

% Define the system name command
\newcommand{\sys}{\textit{KernelSurvey}\xspace}

\begin{document}

% \thanks{Identify applicable funding agency here. If none, delete this.}


% \author{

% \IEEEauthorblockN{1\textsuperscript{st} Yusheng Zheng}
% \IEEEauthorblockA{\textit{Eunomia. Inc.} \\
% % \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% \and

% \IEEEauthorblockN{2\textsuperscript{nd} Yiwei Yang}
% \IEEEauthorblockA{\textit{UC Santa Cruz} \\
% % \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% }


% As artificial intelligence transforms software development, understanding large-scale legacy systems like the Linux kernel becomes even more critical. With 30+ years of evolution and millions of lines of C code built in a pre-AI era, the design rationale, trade-offs, and historical context behind critical features are often buried within millions of unstructured commit messages and mailing list discussions. To bridge this gap between legacy systems and AI-powered development, we introduce \sys, a novel multi-agent framework that systematically analyzes software evolution by simulating an open-source community. \sys employs a team of specialized Large Language Model (LLM) agents—emulating roles such as maintainer, contributor, and security expert—that collaboratively examine commits, patches, and discussions to extract design decisions, identify bug patterns, and trace feature dependencies from their unique perspectives, mirroring real open-source dynamics. Our key insight is by treating LLM Agents as human participants in a socio-technical system,  acknowledging that software development is also a social activity and thereby enabling the application of established social science techniques, \sys can employs carefully designed surveys that agents answer based on development artifacts, enabling the application of established social science techniques and quantitative analysis of software evolution. We apply \sys to the Linux kernel's eBPF subsystem, analyzing over 15,000 commits and 150,000 emails. By transforming this unstructured history into a structured, queryable model, our multi-agent approach enables analyses previously considered intractable. It systematically identifies distinct feature lifecycles (from development to optimization), pinpoints bug-prone components, maps emergent dependencies between features, and highlights under-explored areas requiring attention. These findings, validated by domain experts, provide a new, scalable method for performing longitudinal, socio-technical analysis of software projects, demonstrating how AI can effectively understand and work with legacy codebases built long before the AI era. Furthermore, \sys can be directly applied to other subsystems within Linux, enabling a wide range of empirical studies. The code and dataset will be made open source upon acceptance.
% % Modern software systems like the Linux kernel are among the world's largest and most intricate codebases, continually evolving with new features and increasing complexity. Understanding these systems poses significant challenges due to their scale and the unstructured nature of development artifacts such as commits and mailing list discussions. We introduce \sys, the first LLM-driven methodology designed to systematically explore and analyze large-scale codebases. The central principle behind \sys is to treat LLMs as human participants, acknowledging that software development is also a social activity and thereby enabling the application of established social science techniques. By carefully designing surveys, \sys transforms unstructured data—such as commits, emails—into organized, structured, and analyzable datasets. This enables quantitative analysis of complex software evolution and uncovers valuable insights related to design, implementation, maintenance, reliability, and security.
% The Linux kernel represents one of humanity's most complex software artifacts, with 30+ years of evolution and millions of lines of legacy C code. As we enter the Foundation Model (FM) era, understanding how AI can help comprehend and maintain such systems becomes critical. We present \sys, a novel multi-agent LLM framework that creates a virtual Linux community to systematically analyze kernel development. Unlike traditional single-model approaches, \sys employs specialized agents—Maintainer, Contributor, Security Expert—that collaborate to interpret kernel artifacts from diverse perspectives, mirroring real open-source dynamics. This multi-agent approach addresses two key challenges: (1) How will inner and open-source collaboration evolve in the FM era? (2) How to integrate legacy software in future AIware?

% To demonstrate the effectiveness of \sys, we apply it to the Linux kernel's eBPF subsystem. We construct the Linux-bpf dataset, comprising over 670 features and 16,000 commits from the Linux community. Our quantitative analysis uncovers important insights into the evolution of eBPF, such as development patterns, feature interdependencies, and areas requiring attention for reliability and security—insights that have been initially validated by eBPF experts. Furthermore, \sys can be directly applied to other subsystems within Linux and to other large-scale software projects. By providing a versatile tool for systematic analysis, \sys facilitates a deeper understanding of complex software systems, enabling improvements across a variety of domains and supporting a wide range of empirical studies. The code and dataset will be made available upon acceptance.


\begin{abstract}
Understanding large-scale legacy systems like the Linux kernel is critical as AI transforms software development. With 30+ years of evolution, the design rationale and context behind kernel features are buried within millions of unstructured commits and discussions. We introduce \sys, a multi-agent LLM framework that analyzes software evolution by simulating an open-source community. Specialized agents (maintainer, contributor, security expert) collaboratively examine development artifacts to extract design decisions, identify bug patterns, and trace feature dependencies. By treating LLM agents as human participants in a socio-technical system, \sys applies established social science techniques through carefully designed surveys, transforming unstructured data into analyzable datasets and knowledge bases. We apply \sys to Linux's eBPF subsystem (15,000+ commits, 150,000+ emails), enabling previously intractable analyses: identifying feature lifecycles, pinpointing bug-prone components, mapping dependencies, and highlighting under-explored areas. Domain experts validated these findings, demonstrating a scalable method for longitudinal socio-technical analysis of legacy codebases. \sys is directly applicable to other Linux subsystems, enabling diverse empirical studies. Code and dataset will be open-sourced upon acceptance.
\end{abstract}

\maketitle

\section{Introduction}

As artificial intelligence transforms software development, a critical challenge emerges: how can AI systems understand and work with massive legacy codebases built long before the AI era? Large-scale systems like the Linux kernel represent 30+ years of evolution, with millions of lines of C code encoding decades of implicit knowledge, design decisions, and trade-offs. The design rationale and historical context behind critical features are buried within millions of unstructured commit messages and mailing list discussions—artifacts created by humans for humans. This gap between legacy development artifacts and modern AI capabilities prevents effective integration of established codebases with AI-powered development tools.

The Linux kernel exemplifies this challenge at scale. As the foundation of everything from cloud infrastructure to embedded devices, it embodies one of humanity's most complex collaborative software efforts. The \textit{extended Berkeley Packet Filter} (eBPF)\cite{ebpf} subsystem illustrates both the kernel's continuous evolution and the opacity of its development history. Critical design decisions such as the introduction of \texttt{bpf\_link}\cite{bpflink} for program attachment, the shift from helpers to kfuncs\cite{kfuncs}, and efforts toward Turing completeness remain scattered across commits, patches, and email threads. While these artifacts contain invaluable insights about feature evolution, bug patterns, and architectural trade-offs, they resist systematic analysis. Understanding not just what changed but why it changed, and how different stakeholders perceived these changes, requires new approaches that can bridge the pre-AI and AI eras of software development.

Recent advancements in artificial intelligence, particularly in Large Language Models (LLMs) like GPT-4o\cite{gpt4o} and O1~\cite{o1}, have opened new opportunities to address these challenges. LLMs have shown great promise in automating software engineering tasks such as kenrel eBPF code generation\cite{zheng2024kgent}, bug detection\cite{li2024enhancing}, debugging\cite{chen2023teaching}, and error fixing\cite{deligiannis2023fixing}. However, most current applications of LLMs focus on well-defined tasks involving source code or documented APIs. The critical challenge remains: how can AI systems understand and work with massive legacy codebases that were developed long before AI existed, containing decades of implicit knowledge and design decisions?

% In this paper, we introduce \emph{\sys}, a novel methodology that leverages Large Language Models (LLMs) to systematically transform unstructured data—such as commit histories and emails\cite{linux,tan2019communicate,schneider2016differentiating}—into structured datasets for large-scale software analysis. Drawing inspiration from sociological surveys that utilize human participants to gather extensive data, \sys employs LLMs to emulate this process, enabling efficient and scalable analysis of software development artifacts. By focusing on the vast amount of text produced during software development, \sys allows us to answer questions that were previously difficult to tackle using only structured data in large real-world systems. Through data analysis enabled by \sys, we can explore questions such as:
In this paper, we introduce \sys, a novel multi-agent LLM framework that bridges the gap between AI-powered development tools and legacy systems through a socio-technical approach. Unlike single-model approaches and existing multi-agent systems~\cite{lmase2024,agent4se2024}, \sys creates a virtual Linux community where specialized agents—representing maintainers, contributors, and security experts—collaboratively analyze kernel artifacts. Drawing inspiration from established social science techniques, particularly survey methodology used in sociological research, \sys treats LLM agents as human participants in a socio-technical system. By employing carefully designed surveys that agents answer based on development artifacts (commits, emails, patches)\cite{linux,tan2019communicate,schneider2016differentiating}, the framework transforms unstructured artifacts—scaling to 15,000+ commits and 150,000+ emails—into structured, analyzable datasets. Each agent examines artifacts through their unique lens, capturing not just \emph{what} changed, but the diverse perspectives of the specific individuals who drove those changes. This multi-agent approach enables quantitative socio-technical analysis of 30+ years of development history built before the AI era, making it tractable for modern AI systems. Through collaborative analysis enabled by \sys, we can explore questions such as:


\begin{itemize}
    \item ``How do new feature introductions impact the stability and performance of existing kernel components?''
    \item ``Are there identifiable phases in the lifecycle of a feature, such as initial development, stabilization, and optimization?''
    \item ``How has the functionality of a specific eBPF feature evolved over successive commits?''
    \item ``Which components or files in the Linux kernel have the highest bug frequency?''
    \item ``What lessons can be learned from the development history of kernel eBPF that can be applied to improving other eBPF runtimes?''
    \item ``What dependencies have emerged between features and component?''
\end{itemize}

% To demonstrate the efficacy of \sys, we apply it to the \textit{Linux-bpf dataset}, which contains over 670 features, 15,000 commits, and 150,000 emails related to the development of the eBPF subsystem. Through this structured dataset, we uncover new insights into the design and evolution of features like \texttt{bpf\_link}, and highlight trends that were previously hidden within the unstructured data. These insights have been initially confirmed by eBPF experts.
To demonstrate the efficacy of \sys, we apply it to the \textit{Linux-bpf dataset}, which contains over 670 features, 15,000 commits, and 150,000 emails related to the development of the eBPF subsystem. Our multi-agent analysis reveals fascinating divergences: maintainer agents prioritize stability and backward compatibility, while contributor agents focus on feature velocity. Security expert agents flag vulnerability patterns others miss. Through this multi-perspective analysis, we uncover new insights into features like \texttt{bpf\_link}, revealing how different stakeholders perceive its evolution differently, and identify under-explored areas of eBPF that require attention for various use cases. These multi-agent insights have been validated by eBPF experts, who confirm that the agent perspectives mirror real community dynamics.

% The key contributions of this paper are as follows:
% 
% \begin{itemize}
%     \item We introduce \emph{\sys}, a novel methodology that leverages LLMs to transform unstructured data produced in software development into structured datasets via surveys, enabling systematic analysis of software evolution. To the best of our knowledge, \emph{\sys} is the first methodology that leverages LLMs for the systematic analysis of large-scale codebases.
%     \item We present the \textit{Linux-bpf dataset}, a structured dataset comprising over 670 features, 15,000 commits, and 150,000 emails related to the eBPF subsystem in the Linux kernel.
%     \item We apply the \emph{\sys} methodology to build an LLM-driven agent system, allowing us to perform systematic analysis on the \textit{Linux-bpf dataset}.
%     \item We demonstrate that the \emph{\sys} methodology reveals new insights into the evolution of eBPF kernel features that are impossible to uncover using traditional methods. By combining traditional data analysis methods with eBPF experts' domain knowledge and historical context, we also initially verified the consistency and correctness of the data.
%     \item We identify and highlight under-explored areas of eBPF to support various use cases with the help of \emph{\sys}, pointing out interesting research directions.
% \end{itemize}
The key contributions of this paper are as follows:

\begin{itemize}
    \item We introduce \sys, a multi-agent LLM framework that emulates OSS stakeholder personas for socio-technical analysis of the Linux kernel.
    \item We demonstrate that the \emph{\sys} reveals new insights into the evolution of eBPF kernel features that are hard to uncover using traditional methods. By combining traditional data analysis methods with eBPF experts' domain knowledge and historical context, we also initially verified the consistency and correctness of the data.
    \item We identify and highlight under-explored areas of eBPF to support various use cases with the help of \emph{\sys}, pointing out interesting research directions.
\end{itemize}

% The remainder of this paper is structured as follows. We review background in Section~\ref{sec:related}, followed by a detailed explanation of the \sys methodology in Section~\ref{sec:methodology}. Section~\ref{sec:analysis} presents our analysis of the Linux-bpf dataset and the insights gained from it. Sections~\ref{sec:limitations} and~\ref{sec:future} conclude with a discussion of current limitations and future work. All artifacts will be made available upon acceptance.
The remainder of this paper is structured as follows. We review background in Section~\ref{sec:related}, followed by a detailed explanation of the \sys multi-agent architecture in Section~\ref{sec:design}. Section~\ref{sec:analysis} presents our multi-perspective analysis of the Linux-bpf dataset and insights into software evolution. Sections~\ref{sec:limitations} and~\ref{sec:future} conclude with a discussion of current limitations and future work. All artifacts will be made available upon acceptance.

\section{Background}
\label{sec:related}

This section discuss the role of Large Language Models in software development, the complexities of Linux kernel development, and the importance of survey methodologies in empirical software engineering research.

\subsection{LLMs in Software Development}

Large Language Models (LLMs), such as GPT-4o and Claude, have significantly impacted software development~\cite{jin2024llms}, particularly in automating tasks like code generation, debugging, and testing. Tools like GitHub Copilot~\cite{copilot} leverage these models to enhance developer productivity by providing intelligent code suggestions. Recent work has explored multi-agent systems for software engineering~\cite{lmase2024,agent4se2024}, repository mining with LLMs~\cite{primes2024}, and automated commit analysis~\cite{commitgen2024,apce2025}. Despite these advancements, challenges such as hallucinations—where incorrect but plausible code is generated—still persist~\cite{fan2023large,ji2023survey}. While some efforts have focused on deep research agents for large codebases~\cite{coderesearcher2025}, exploring the socio-technical evolution of legacy systems using stakeholder personas remains underexplored.

Additionally, using LLMs for summarizing test results, decision-making, and converting unstructured data into structured formats is becoming increasingly common in both academia~\cite{jin2024comprehensive,iourovitski2024grade,patel2024lotus} and industry~\cite{llmnvida}. Recent efforts have explored LLM-based chatbots for mining software repositories~\cite{llmchatbotsmsr2024}. This capability is especially valuable in environments where massive amounts of unstructured data—such as logs, emails, or messages—exist. The ability to systematically extract insights from this data enables more efficient analysis and has been widely applied to tasks like market research~\cite{brand2023using}.

\subsection{Software Evolution and Its Challenges}
Software evolution involves the continuous modification and adaptation of systems to meet changing requirements~\cite{lehman1996laws}. According to Lehman's laws, systems must evolve to remain useful, but this often increases complexity without proactive management. In large-scale systems like the Linux kernel~\cite{linux}, evolution is non-linear, involving numerous contributors and revisions, which leads to intricate interdependencies~\cite{israeli2010linux}. The Linux kernel generates vast unstructured data, including commit logs and email threads, which traditional analysis methods struggle to process~\cite{mens2008introduction}. These artifacts contain rich contextual information about design decisions, but their volume and unstructured format hinder conventional techniques. Additionally, evolving systems accumulate \emph{technical debt}~\cite{brown2010managing}, increasing maintenance costs and reducing reliability. Addressing these challenges requires innovative approaches capable of handling large-scale unstructured data to provide actionable insights.



\subsection{Survey Methodology and Empirical Studies}

% Empirical studies in software engineering~\cite{perry2000empirical} are crucial for understanding how software evolves and how development practices affect system reliability, performance, and maintainability. Traditional surveys rely on structured questionnaires or interviews but are limited by scale and biases such as subjective recall or incomplete responses. In contrast, the \textit{\sys} methodology automates data collection using LLMs to extract structured insights from unstructured data like commit histories and mailing lists. This approach enables large-scale analysis and allows us to answer questions that traditional methods cannot.
Empirical studies in software engineering~\cite{perry2000empirical} are crucial for understanding how software evolves and how development practices affect system reliability, performance, and maintainability. Traditional surveys rely on structured questionnaires or interviews but are limited by scale and biases such as subjective recall or incomplete responses. In contrast, the \sys methodology employs multiple specialized LLM agents to extract multi-perspective insights from unstructured data like commit histories and mailing lists. This multi-agent approach not only enables large-scale analysis but reveals how different stakeholders interpret the same changes, providing insights into collaboration dynamics that traditional methods cannot capture.

\input{method}

\input{case-study}
\input{limit-futurework}

\section{Conclusion}

% This paper introduced \emph{\sys}, the first methodology that leverages LLMs for systematically exploring and analyzing large-scale codebase through a survey-based approach. Applied to the Linux eBPF subsystem, \emph{\sys} successfully uncovered patterns in feature evolution and design that traditional methods overlook. Despite some limitations, our approach provides a valuable framework for understanding the growth of real-world software systems. Future work will expand its scope, enhance LLM capabilities, and apply \emph{\sys} to other large-scale codebases. We also invite collaborators to work together on the ongoing development and refinement of this pioneering methodology.
This paper introduced \sys, a multi-agent LLM framework that creates a virtual Linux community for analyzing kernel evolution. Applied to the Linux eBPF subsystem, \sys successfully revealed how different stakeholders perceive feature evolution differently, uncovering collaboration patterns and design tensions that single-model approaches miss. By treating LLMs as human participants in a socio-technical system, our framework transforms software archaeology into systematic empirical analysis. Future work will expand agent specializations, enhance consensus mechanisms, and apply \sys to other subsystems. We invite collaborators to explore how multi-agent approaches can transform our understanding of large-scale software evolution.

% In this paper, we introduce \emph{\sys}, a novel approach that leverages LLMs to systematically transform unstructured data into structured datasets for analysis. By focusing on commit histories and developer communications, \sys enables us to answer questions that were previously impossible to tackle using only unstructured data in large real-world systems. Structured data analysis allows us to explore questions like:

% \begin{itemize}
%     \item \textbf{Design Rationale and Decision-Making:}
%     \begin{itemize}
%         \item What were the primary motivations behind introducing specific eBPF features or bug fixes?
%         \item How do design rationales discussed in developer communications correlate with implementation choices in commits?
%         \item What trade-offs have been considered in the design of eBPF features, such as flexibility vs. performance?
%     \end{itemize}
    
%     \item \textbf{Feature Evolution and Integration:}
%     \begin{itemize}
%         \item How has the functionality of a specific eBPF feature, like \texttt{bpf\_link}, evolved over successive commits?
%         \item What dependencies have emerged between eBPF features and other subsystems within the Linux kernel?
%         \item How do new feature introductions impact the stability and performance of existing eBPF features?
%     \end{itemize}
    
%     \item \textbf{Development Patterns and Trends:}
%     \begin{itemize}
%         \item What patterns can be observed in the frequency and nature of commits related to specific eBPF features over time?
%         \item Are there identifiable phases in the lifecycle of eBPF features, such as initial development, stabilization, and optimization?
%         \item How do periods of high commit activity correlate with major kernel releases or external events?
%     \end{itemize}
    
%     \item \textbf{Collaborative Dynamics and Communication:}
%     \begin{itemize}
%         \item How do discussions in mailing lists influence the direction and prioritization of eBPF feature development?
%         \item What roles do key maintainers play in shaping the evolution of the eBPF subsystem?
%         \item How does the collaboration between different contributors affect the consistency and coherence of eBPF feature implementations?
%     \end{itemize}
    
%     \item \textbf{Impact Assessment and Maintenance:}
%     \begin{itemize}
%         \item What are the common causes of feature regressions in eBPF, and how are they addressed in subsequent commits?
%         \item How do maintainers assess the long-term maintenance needs of eBPF features based on commit history and developer feedback?
%         \item What metrics can be derived from structured data to evaluate the reliability and performance improvements of eBPF features?
%     \end{itemize}
    
%     \item \textbf{Adoption and Usage Insights:}
%     \begin{itemize}
%         \item How has the adoption of eBPF features like \texttt{bpf\_link} grown within the Linux kernel, and what factors have driven this adoption?
%         \item What usage patterns emerge from the commit history that indicate how end-users interact with specific eBPF features?
%         \item How do enhancements to eBPF influence its applicability in emerging domains such as cloud-native environments and security monitoring?
%     \end{itemize}
    
%     \item \textbf{Knowledge Transfer and Documentation:}
%     \begin{itemize}
%         \item How effectively do commit messages and mailing list discussions convey the necessary information for future maintenance and development?
%         \item What gaps exist between developer communications and the actual codebase, and how can structured data help bridge these gaps?
%         \item How does the clarity and detail of commit messages impact the ease of understanding feature evolution for new contributors?
%     \end{itemize}
    
%     \item \textbf{Comparative Analysis Across Subsystems:}
%     \begin{itemize}
%         \item How does the evolution of eBPF compare to other subsystems within the Linux kernel in terms of complexity and development pace?
%         \item What lessons can be learned from the development history of eBPF that can be applied to improving other kernel subsystems?
%         \item Are there common factors that contribute to the successful integration and maintenance of features across different kernel subsystems?
%     \end{itemize}
    
%     \item \textbf{Technical Design and Implementation Components:}
%     \begin{itemize}
%         \item How do logical design principles of eBPF translate into specific implementation components within the kernel?
%         \item What are the key implementation challenges faced during the development of eBPF, and how were they overcome?
%         \item How have optimizations in eBPF’s implementation impacted its overall performance and efficiency?
%         \item How does the implementation of eBPF ensure compatibility and interoperability with other kernel subsystems?
%         \item What role do helper functions play in the implementation of eBPF features, and how have they evolved over time?
%         \item How does the implementation of the eBPF verifier contribute to the security and reliability of eBPF programs?
%     \end{itemize}
    
%     \item \textbf{Logic Design and Real Components:}
%     \begin{itemize}
%         \item How does the logical design of eBPF programs influence their implementation within the Linux kernel?
%         \item What are the possible logical components and their corresponding implementation components in eBPF?
%         \item How do design criteria of the eBPF verifier affect the implementation of eBPF helper functions?
%         \item How have the interactions between eBPF’s logical components and other kernel subsystems been managed in the implementation?
%         \item How do logical design changes in eBPF correlate with implementation modifications in the kernel codebase?
%     \end{itemize}
    
%     \item \textbf{Deep Insight Questions for Design and Implementation Gap:}
%     \begin{itemize}
%         \item How do logical abstractions in eBPF design ensure seamless integration with kernel-level operations?
%         \item What are the key design principles that guided the implementation of persistent eBPF program attachments like \texttt{bpf\_link}?
%         \item How has the design of eBPF’s execution environment influenced its implementation efficiency and security?
%         \item



% In this paper, we introduce \emph{\sys}, a novel approach that leverages LLMs to systematically transform unstructured data into structured datasets for analysis. By focusing on commit histories and developer communications, \sys enables us to answer questions that were previously impossible to tackle using only unstructured data in large real-world systems. Structured data analysis allows us to explore questions like:





 

% We make several interesting observations: 

% - Call attention to under-explored areas of the eBPF tool chain, runtime to support the various use cases. 

% - Highlight interesting research directions. 

% We also deployed a open-source pipeline and database for real time open-source eBPF community, which can help you check and analysis quantatively, and can be easily applied to other Linux subsystems.											 

 

% ## the challendges of Analysis Linux Community: 

 

% Too much data in one of the largest community of the world 

% Unstruct data, including reviews, patchs, annoounces, discussions all together 

% Self host on mail without platforms like github 

 

% It’s hard to use traditional NLP mothod or data metrics to analysis them. Doing survey with kernel experts need a huge amond of money and 

 

% ## Methods 

 

 

% Kernel or eBPF Experts give a Survey and Questionnaire 

% Collect meta data of commits and mails with traditional method, including timestamps, mail, thread logic information 

% Connect the data 

 

% Allow llm to answer the Survey and Questionnaire based on the mails and patches,  

% ## Validate the results with kernel experts 

% Talk to them and collect feed backs. Also evalute the performance of the system. 

% eBPF the goal is to create innovation. The eBPF is continue envlove and no standard. 

% - Tools and verifier need to be portable
% - 

\bibliographystyle{plain}
\bibliography{cite}
\end{document}
